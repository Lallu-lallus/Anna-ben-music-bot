from __future__ import unicode_literals

import asyncio
import math
import os
import time

import aiofiles
import aiohttp
import wget
from pyrogram import Client, filters
from pyrogram.errors import FloodWait, MessageNotModified
from pyrogram.types import Message
from youtubesearchpython import SearchVideos
from yt_dlp import YoutubeDL
import youtube_dl
from youtube_search import YoutubeSearch
from plugins.modules.play import arq

import requests

## Extra Fns -------------------------------

# Convert hh:mm:ss to seconds
def time_to_seconds(time):
    stringt = str(time)
    return sum(int(x) * 60 ** i for i, x in enumerate(reversed(stringt.split(':'))))


## Commands --------------------------------


@Client.on_message(filters.command(["song", "s"]))
def a(client, message):
    query=message.text
    print(query)
    m = message.reply('ğŸ” ğ—¦ğ—²ğ—®ğ—¿ğ—°ğ—µğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—¦ğ—¼ğ—»ğ—´...')
    ydl_opts = {"format": "bestaudio[ext=m4a]"}
    try:
        results = []
        count = 0
        while len(results) == 0 and count < 6:
            if count>0:
                time.sleep(1)
            results = YoutubeSearch(query, max_results=1).to_dict()
            count += 1
        # results = YoutubeSearch(query, max_results=1).to_dict()
        try:
            link = f"https://youtube.com{results[0]['url_suffix']}"
            # print(results)
            title = results[0]["title"]
            thumbnail = results[0]["thumbnails"][0]
            duration = results[0]["duration"]

            ## UNCOMMENT THIS IF YOU WANT A LIMIT ON DURATION. CHANGE 1800 TO YOUR OWN PREFFERED DURATION AND EDIT THE MESSAGE (30 minutes cap) LIMIT IN SECONDS
            # if time_to_seconds(duration) >= 1800:  # duration limit
            #     m.edit("Exceeded 30mins cap")
            #     return

            views = results[0]["views"]
            thumb_name = f'thumb{message.message_id}.jpg'
            thumb = requests.get(thumbnail, allow_redirects=True)
            open(thumb_name, 'wb').write(thumb.content)

        except Exception as e:
            print(e)
            m.edit('ğ…ğ¨ğ®ğ§ğ ğğ¨ğ­ğ¡ğ¢ğ§ğ . ğ“ğ«ğ² ğ‚ğ¡ğšğ§ğ ğ¢ğ§ğ  ğ“ğ¡ğ ğ’ğ©ğğ¥ğ¥ğ¢ğ§ğ  ğ€ ğ‹ğ¢ğ­ğ­ğ¥ğ ğŸ˜')
            return
    except Exception as e:
        m.edit(
            "â ğ¹ğ‘œğ‘¢ğ‘›ğ‘‘ ğ‘ğ‘œğ‘¡â„ğ‘–ğ‘›ğ‘”. ğ’ğ¨ğ«ğ«ğ².\n\nğ–¯ğ—…ğ–¾ğ–ºğ—Œğ–¾ ğ–³ğ—‹ğ—’ ğ– ğ—€ğ–ºğ—‚ğ—‡ ğ–®ğ—‹ ğ–²ğ–¾ğ–ºğ—‹ğ–¼ğ— ğ–ºğ— Google.com ğ–¥ğ—ˆğ—‹ ğ–¢ğ—ˆğ—‹ğ—‹ğ–¾ğ–¼ğ— ğ–²ğ—‰ğ–¾ğ—…ğ—…ğ—‚ğ—‡ğ—€ ğ—ˆğ–¿ ğ—ğ—ğ–¾ ğ™ğ™¤ğ™£ğ™œ.\n\nEg.`Believer`"
        )
        print(str(e))
        return
    m.edit("`ğŸ¸ğ¼ ğ¹ğ‘œğ‘¢ğ‘›ğ‘‘ ğ‘ ğ‘ ğ‘œğ‘›ğ‘” ğ‘ğ‘™ğ‘’ğ‘ğ‘ ğ‘’ ğ‘¤ğ‘ğ‘–ğ‘¡ğ‘’ ğ¼ ğ‘¢ğ‘ğ‘™ğ‘œğ‘ğ‘‘ğ‘–ğ‘›ğ‘” ğ‘–ğ‘¡.....`")
    try:
        with youtube_dl.YoutubeDL(ydl_opts) as ydl:
            info_dict = ydl.extract_info(link, download=False)
            audio_file = ydl.prepare_filename(info_dict)
            ydl.process_info(info_dict)
        rep =  f'ğŸ§ ğ—§ğ—¶ğ˜ğ˜ğ—¹ğ—² : [{title[:35]}]\nâ³ ğ——ğ˜‚ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—» : `{duration}`\nğŸ‘€ ğ—©ğ—¶ğ—²ğ˜„ğ˜€ : `{views}`\n\nğŸ“® ğ—•ğ˜†: {message.from_user.mention()}\nğŸ“¤ ğ—•ğ˜† : @Movie_wrld_grp'
        secmul, dur, dur_arr = 1, 0, duration.split(':')
        for i in range(len(dur_arr)-1, -1, -1):
            dur += (int(dur_arr[i]) * secmul)
            secmul *= 60
        message.reply_audio(audio_file, caption=rep, parse_mode='HTML',quote=False, title=title, duration=dur, performer=str(info_dict["uploader"]), thumb=thumb_name)
        m.delete()
    except Exception as e:
        m.edit('ğ™ğ™–ğ™ğ™¡ğ™šğ™™\n\n`Plesase Try Again Later`')
        print(e)
    try:
        os.remove(audio_file)
        os.remove(thumb_name)
    except Exception as e:
        print(e)


@Client.on_message(filters.command(["video", "v"]))
async def vsong(client, message: Message):
    urlissed = get_text(message)

    pablo = await client.send_message(
        message.chat.id, f"**ğŸ” ğ’ğğšğ«ğœğ¡ğ¢ğ§ğ ..** `{urlissed}`"
    )
    if not urlissed:
        await pablo.edit("Invalid Command Syntax Please Check help Menu To Know More!")
        return

    search = SearchVideos(f"{urlissed}", offset=1, mode="dict", max_results=1)
    mi = search.result()
    mio = mi["search_result"]
    mo = mio[0]["link"]
    thum = mio[0]["title"]
    fridayz = mio[0]["id"]
    mio[0]["channel"]
    kekme = f"https://img.youtube.com/vi/{fridayz}/hqdefault.jpg"
    await asyncio.sleep(0.6)
    url = mo
    sedlyf = wget.download(kekme)
    opts = {
        "format": "best",
        "addmetadata": True,
        "key": "FFmpegMetadata",
        "prefer_ffmpeg": True,
        "geo_bypass": True,
        "nocheckcertificate": True,
        "postprocessors": [{"key": "FFmpegVideoConvertor", "preferedformat": "mp4"}],
        "outtmpl": "%(id)s.mp4",
        "logtostderr": False,
        "quiet": True,
    }
    try:
        with YoutubeDL(opts) as ytdl:
            ytdl_data = ytdl.extract_info(url, download=True)
    except Exception as e:
        await event.edit(event, f"**Download Failed** \n**Error :** `{str(e)}`")
        return
    c_time = time.time()
    file_stark = f"{ytdl_data['id']}.mp4"
    capy = f"""
**ğŸ·ï¸ Video:** [{thum}]({mo})
**ğŸ¬ Requested by:** {message.from_user.mention}
"""
    await client.send_video(
        message.chat.id,
        video=open(file_stark, "rb"),
        duration=int(ytdl_data["duration"]),
        file_name=str(ytdl_data["title"]),
        thumb=sedlyf,
        caption=capy,
        supports_streaming=True,
        progress=progress,
        progress_args=(
            pablo,
            c_time,
            f"**ğŸ“¥ Download** `{urlissed}`",
            file_stark,
        ),
    )
    await pablo.delete()
    for files in (sedlyf, file_stark):
        if files and os.path.exists(files):
            os.remove(files)
